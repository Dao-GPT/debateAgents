{"version":3,"file":"lib_worker_js.cfac58e4ec51dadfb6ba.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACtD;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAQ;AAC/B;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAkD;AAChF;AACA;AACA,8CAA8C,mDAAmD;AACjG;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD;AAC/E;AACA;AACA,wCAAwC,+CAA+C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB,EAAE,gBAAgB,EAAE,KAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iDAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxWA;AACA;AACA;AACO,wBAAwB;AACxB,yBAAyB;AACzB;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA,gBAAgB,iBAAiB,kBAAkB,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,yDAAyD,gBAAgB,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yDAAyD,gBAAgB,IAAI;AAC7E,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiI;AACjI;;;;;;;UCzVA;UACA;;UAEA;UACA,SAAS,gCAAmB;UAC5B;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA,uDAAuD,gCAAmB;;UAE1E;UACA;UACA;;;;;WCtBA;WACA,gCAAmB;WACnB;WACA,KAAK,gCAAmB,wBAAwB,gCAAmB;WACnE,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,gCAAmB;;;;;WCAnB;WACA,gCAAmB;WACnB;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA,+BAA+B;AAC/B,yCAAyC;AACzC,2DAA2D;AAE3D,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;AAEI;AAOF;AAI/B,UAAU,CAAC,MAAM,GAAG,EAAE,CAAC;AAEvB,MAAM,aAAc,SAAQ,2EAAwB;IAC1C,OAAO,CAAC,YAAiB;QAC/B,IAAI,YAAY,CAAC,MAAM,CAAC,EAA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","sources":["webpack://@jupyterlite/xeus/@jupyterlite/xeus/./node_modules/@jupyterlite/contents/lib/drivefs.js","webpack://@jupyterlite/xeus/@jupyterlite/xeus/./node_modules/@jupyterlite/contents/lib/emscripten.js","webpack://@jupyterlite/xeus/@jupyterlite/xeus/./node_modules/comlink/dist/esm/comlink.mjs","webpack://@jupyterlite/xeus/@jupyterlite/xeus/webpack/bootstrap","webpack://@jupyterlite/xeus/@jupyterlite/xeus/webpack/runtime/define property getters","webpack://@jupyterlite/xeus/@jupyterlite/xeus/webpack/runtime/hasOwnProperty shorthand","webpack://@jupyterlite/xeus/@jupyterlite/xeus/webpack/runtime/make namespace object","webpack://@jupyterlite/xeus/@jupyterlite/xeus/./src/worker.ts","webpack://@jupyterlite/xeus/webpack/bootstrap","webpack://@jupyterlite/xeus/webpack/runtime/hasOwnProperty shorthand","webpack://@jupyterlite/xeus/webpack/runtime/sharing","webpack://@jupyterlite/xeus/webpack/before-startup","webpack://@jupyterlite/xeus/webpack/startup","webpack://@jupyterlite/xeus/webpack/after-startup"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nimport { DIR_MODE, SEEK_CUR, SEEK_END, } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    getattr(node) {\n        return {\n            ...this.fs.API.getattr(this.fs.realPath(node)),\n            mode: node.mode,\n            ino: node.id,\n        };\n    }\n    setattr(node, attr) {\n        for (const [key, value] of Object.entries(attr)) {\n            switch (key) {\n                case 'mode':\n                    node.mode = value;\n                    break;\n                case 'timestamp':\n                    node.timestamp = value;\n                    break;\n                default:\n                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                    break;\n            }\n        }\n    }\n    lookup(parent, name) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n        }\n        return this.fs.createNode(parent, name, result.mode, 0);\n    }\n    mknod(parent, name, mode, dev) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(parent, name, mode, dev);\n    }\n    rename(oldNode, newDir, newName) {\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDir), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    readdir(node) {\n        return this.fs.API.readdir(this.fs.realPath(node));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        this._baseUrl = baseUrl;\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return Number.parseInt(this.request({ method: 'getmode', path: this.normalizePath(path) }));\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({ method: 'get', path: this.normalizePath(path) });\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Turn datetimes into proper objects\n        stats.atime = new Date(stats.atime);\n        stats.mtime = new Date(stats.mtime);\n        stats.ctime = new Date(stats.ctime);\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = new ContentsAPI(options.baseUrl, options.driveName, options.mountpoint, this.FS, this.ERRNO_CODES);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/// <reference path=\"../../../node_modules/@types/emscripten/index.d.ts\" />\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\n//# sourceMappingURL=emscripten.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Copyright (c) Thorsten Beier\n// Copyright (c) JupyterLite Contributors\n// Distributed under the terms of the Modified BSD License.\n\nconsole.log('worker loaded');\n\nimport { expose } from 'comlink';\n\nimport {\n  DriveFS,\n  DriveFSEmscriptenNodeOps,\n  IEmscriptenFSNode,\n  IStats\n} from '@jupyterlite/contents';\n\ndeclare function createXeusModule(options: any): any;\n\nglobalThis.Module = {};\n\nclass StreamNodeOps extends DriveFSEmscriptenNodeOps {\n  private getNode(nodeOrStream: any) {\n    if (nodeOrStream['node']) {\n      return nodeOrStream['node'];\n    }\n    return nodeOrStream;\n  }\n\n  lookup(parent: IEmscriptenFSNode, name: string): IEmscriptenFSNode {\n    return super.lookup(this.getNode(parent), name);\n  }\n\n  getattr(node: IEmscriptenFSNode): IStats {\n    return super.getattr(this.getNode(node));\n  }\n\n  setattr(node: IEmscriptenFSNode, attr: IStats): void {\n    super.setattr(this.getNode(node), attr);\n  }\n\n  mknod(\n    parent: IEmscriptenFSNode,\n    name: string,\n    mode: number,\n    dev: any\n  ): IEmscriptenFSNode {\n    return super.mknod(this.getNode(parent), name, mode, dev);\n  }\n\n  rename(\n    oldNode: IEmscriptenFSNode,\n    newDir: IEmscriptenFSNode,\n    newName: string\n  ): void {\n    super.rename(this.getNode(oldNode), this.getNode(newDir), newName);\n  }\n\n  rmdir(parent: IEmscriptenFSNode, name: string): void {\n    super.rmdir(this.getNode(parent), name);\n  }\n\n  readdir(node: IEmscriptenFSNode): string[] {\n    return super.readdir(this.getNode(node));\n  }\n}\n\n// TODO Remove this when we don't need StreamNodeOps anymore\nclass LoggingDrive extends DriveFS {\n  constructor(options: DriveFS.IOptions) {\n    super(options);\n\n    this.node_ops = new StreamNodeOps(this);\n  }\n}\n\n// when a toplevel cell uses an await, the cell is implicitly\n// wrapped in a async function. Since the webloop - eventloop\n// implementation does not support `eventloop.run_until_complete(f)`\n// we need to convert the toplevel future in a javascript Promise\n// this `toplevel` promise is then awaited before we\n// execute the next cell. After the promise is awaited we need\n// to do some cleanup and delete the python proxy\n// (ie a js-wrapped python object) to avoid memory leaks\nglobalThis.toplevel_promise = null;\nglobalThis.toplevel_promise_py_proxy = null;\n\nlet resolveInputReply: any;\n\nasync function get_stdin() {\n  const replyPromise = new Promise(resolve => {\n    resolveInputReply = resolve;\n  });\n  return replyPromise;\n}\n\n(self as any).get_stdin = get_stdin;\n\nclass XeusKernel {\n  constructor(resolve: any) {\n    console.log('constructing kernel');\n    this._resolve = resolve;\n  }\n\n  async ready(): Promise<void> {\n    return await globalThis.ready;\n  }\n\n  mount(driveName: string, mountpoint: string, baseUrl: string): void {\n    console.log('mounting drive');\n    const { FS, PATH, ERRNO_CODES } = globalThis.Module;\n\n    if (!FS) {\n      return;\n    }\n\n    this._drive = new LoggingDrive({\n      FS,\n      PATH,\n      ERRNO_CODES,\n      baseUrl,\n      driveName,\n      mountpoint\n    });\n\n    FS.mkdir(mountpoint);\n    FS.mount(this._drive, {}, mountpoint);\n    FS.chdir(mountpoint);\n  }\n\n  cd(path: string) {\n    if (!path || !globalThis.Module.FS) {\n      return;\n    }\n\n    globalThis.Module.FS.chdir(path);\n  }\n\n  async processMessage(event: any): Promise<void> {\n    const msg_type = event.msg.header.msg_type;\n    if (msg_type === '__initialize__') {\n      this._kernelspec = event.msg.kernelspec;\n      await this.initialize();\n\n      return;\n    }\n\n    await this.ready();\n\n    if (\n      globalThis.toplevel_promise !== null &&\n      globalThis.toplevel_promise_py_proxy !== null\n    ) {\n      await globalThis.toplevel_promise;\n      globalThis.toplevel_promise_py_proxy.delete();\n      globalThis.toplevel_promise_py_proxy = null;\n      globalThis.toplevel_promise = null;\n    }\n\n    if (msg_type === 'input_reply') {\n      resolveInputReply(event.msg);\n    } else {\n      this._raw_xserver.notify_listener(event.msg);\n    }\n  }\n\n  private async initialize() {\n    // the location of the kernel on the server\n    // ie `share/jupyter/kernels/${dir}`\n    const dir = this._kernelspec.dir;\n\n    // location of the kernel binary on the server\n    const binary_js = this._kernelspec.argv[0];\n    const binary_wasm = binary_js.replace('.js', '.wasm');\n\n    importScripts(binary_js);\n    globalThis.Module = await createXeusModule({\n      locateFile: (file: string) => {\n        if (file.endsWith('.wasm')) {\n          return binary_wasm;\n        }\n        return file;\n      }\n    });\n    try {\n      await this.waitRunDependency();\n      console.log(globalThis.Module);\n\n      // each kernel can have a `async_init` function\n      // which can do kernel specific **async** initialization\n      // This function is usually implemented in the pre/post.js\n      // in the emscripten build of that kernel\n      if (globalThis.Module['async_init'] !== undefined) {\n        const kernel_root_url = `share/jupyter/kernels/${dir}`;\n        const pkg_root_url = 'share/jupyter/kernel_packages';\n        const verbose = true;\n        await globalThis.Module['async_init'](\n          kernel_root_url,\n          pkg_root_url,\n          verbose\n        );\n      }\n      else{\n        console.log('no async_init found')\n      }\n\n      await this.waitRunDependency();\n\n      this._raw_xkernel = new globalThis.Module.xkernel();\n      this._raw_xserver = this._raw_xkernel.get_server();\n      if (!this._raw_xkernel) {\n        console.error('Failed to start kernel!');\n      }\n      this._raw_xkernel.start();\n    } catch (e) {\n      if (typeof e === 'number') {\n        const msg = globalThis.Module.get_exception_message(e);\n        console.error(msg);\n        throw new Error(msg);\n      } else {\n        console.error(e);\n        throw e;\n      }\n    }\n    this._resolve();\n  }\n\n  private async waitRunDependency() {\n    const promise = new Promise<void>(resolve => {\n      globalThis.Module.monitorRunDependencies = (n: number) => {\n        if (n === 0) {\n          resolve();\n        }\n      };\n    });\n    // If there are no pending dependencies left, monitorRunDependencies will\n    // never be called. Since we can't check the number of dependencies,\n    // manually trigger a call.\n    globalThis.Module.addRunDependency('dummy');\n    globalThis.Module.removeRunDependency('dummy');\n    return promise;\n  }\n  private _resolve: any;\n  private _kernelspec: any;\n  private _raw_xkernel: any;\n  private _raw_xserver: any;\n  private _drive: DriveFS | null = null;\n  //private _ready: PromiseLike<void>;\n}\n\nglobalThis.ready = new Promise(resolve => {\n  console.log('expose(new XeusKernel(resolve));');\n  expose(new XeusKernel(resolve));\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.S = {};\nvar initPromises = {};\nvar initTokens = {};\n__webpack_require__.I = (name, initScope) => {\n\tif(!initScope) initScope = [];\n\t// handling circular init calls\n\tvar initToken = initTokens[name];\n\tif(!initToken) initToken = initTokens[name] = {};\n\tif(initScope.indexOf(initToken) >= 0) return;\n\tinitScope.push(initToken);\n\t// only runs once\n\tif(initPromises[name]) return initPromises[name];\n\t// creates a new share scope if needed\n\tif(!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};\n\t// runs all init snippets from all modules reachable\n\tvar scope = __webpack_require__.S[name];\n\tvar warn = (msg) => {\n\t\tif (typeof console !== \"undefined\" && console.warn) console.warn(msg);\n\t};\n\tvar uniqueName = \"@jupyterlite/xeus\";\n\tvar register = (name, version, factory, eager) => {\n\t\tvar versions = scope[name] = scope[name] || {};\n\t\tvar activeVersion = versions[version];\n\t\tif(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };\n\t};\n\tvar initExternal = (id) => {\n\t\tvar handleError = (err) => (warn(\"Initialization of sharing external failed: \" + err));\n\t\ttry {\n\t\t\tvar module = __webpack_require__(id);\n\t\t\tif(!module) return;\n\t\t\tvar initFn = (module) => (module && module.init && module.init(__webpack_require__.S[name], initScope))\n\t\t\tif(module.then) return promises.push(module.then(initFn, handleError));\n\t\t\tvar initResult = initFn(module);\n\t\t\tif(initResult && initResult.then) return promises.push(initResult['catch'](handleError));\n\t\t} catch(err) { handleError(err); }\n\t}\n\tvar promises = [];\n\tswitch(name) {\n\t}\n\tif(!promises.length) return initPromises[name] = 1;\n\treturn initPromises[name] = Promise.all(promises).then(() => (initPromises[name] = 1));\n};","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(\"./lib/worker.js\");\n",""],"names":[],"sourceRoot":""}